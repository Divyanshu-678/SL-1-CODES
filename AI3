def alphabeta(node, depth, alpha, beta, maximizingPlayer, tree):
   
    if depth == 0 or node not in tree:
        return node  
   
    if maximizingPlayer:
        maxEval = float('-inf')
        for child in tree[node]:
            eval = alphabeta(child, depth - 1, alpha, beta, False, tree)
            maxEval = max(maxEval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break  
        return maxEval
    else:
        minEval = float('inf')
        for child in tree[node]:
            eval = alphabeta(child, depth - 1, alpha, beta, True, tree)
            minEval = min(minEval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break  
        return minEval
       
tree = {}

n = int(input("Enter number of internal nodes: "))

for _ in range(n):
    node = input("\nEnter node name: ")
    children = input(f"Enter children of {node} (space separated): ").split()

   
    processed = []
    for c in children:
        if c.lstrip('-').isdigit():  
            processed.append(int(c))
        else:
            processed.append(c)
    tree[node] = processed

print("\nTree representation:", tree)

depth = int(input("\nEnter depth of tree: "))


optimal_value = alphabeta('A', depth, float('-inf'), float('inf'), True, tree)
print("\n Optimal value at root (A):", optimal_value)
